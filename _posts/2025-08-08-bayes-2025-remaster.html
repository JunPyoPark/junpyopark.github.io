---
layout: post
title: "가장 쉽게 이해하는 베이즈 정리 2025 리마스터 II - 실전 업데이트와 나이브 베이즈"
date: 2025-08-08 10:20:00 +0900
description: "베타-베르누이 업데이트로 사전→사후를 체득하고, 가능도비(LR) 누적으로 다중 증거를 결합, 미니 나이브 베이즈로 스팸 판별까지 한 번에 이해하는 2025 리마스터 후속편."
img: bayes.jpg
tags: [베이즈정리, 베타분포, 베르누이, 가능도비, LR, 나이브베이즈, 머신러닝, 통계, 데이터사이언스]
canonical_url: "https://junpyopark.github.io/bayes-2025-remaster"
author: "박준표"
keywords: "베이즈 정리, 베타 베르누이, 사전 사후, 가능도비, 우도비, 나이브 베이즈, 스팸 필터, 조건부 독립, 업데이트 규칙"
---

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article"
     data-ad-format="fluid" data-ad-client="ca-pub-4993132508717238" data-ad-slot="7426355186"></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script>window.MathJax={tex:{inlineMath:[["\\(","\\)"]],displayMath:[["\\[","\\]"]]}};</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700;900&display=swap" rel="stylesheet">

<style>
  body { font-family: 'Noto Sans KR', sans-serif; background:#ffffff; }
  .card { background:#fff; border:1px solid #e5e7eb; border-radius:0.75rem; }
  .kpi { background:#f9fafb; border-radius:0.5rem; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
  .input { width:100%; }
</style>

<div class="bg-white">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8 py-10 max-w-6xl">
    <header class="text-center mb-10">
      <h1 class="text-3xl sm:text-4xl md:text-5xl font-black text-gray-900">베이즈 정리 2025 리마스터 II</h1>
      <p class="mt-3 text-gray-600 max-w-3xl mx-auto">1편의 정의와 성질을 바탕으로, 이번 편에서는 <b>수식 → 직관 → 실습</b> 흐름으로 연결합니다.</p>
    </header>

    <!-- Section 0: Recap & Formula -->
    <section class="card p-6 mb-10">
      <h2 class="text-2xl font-bold mb-2">0) 1편 요약: 조건부확률 · 독립 · 베이즈 정리</h2>
      <div class="prose prose-sm max-w-none text-gray-800">
        <p>1편에서 다룬 핵심은 다음과 같습니다.</p>
        <ul class="list-disc list-inside">
          <li>조건부확률: \( P(A\mid B) = \dfrac{P(A\cap B)}{P(B)} \), \( P(B\mid A) = \dfrac{P(A\cap B)}{P(A)} \)</li>
          <li>곱셈법칙: \( P(A\cap B) = P(A\mid B)P(B) = P(B\mid A)P(A) \)</li>
          <li>독립: \( P(A\cap B) = P(A)P(B) \) (확장 시 임의의 부분집합 조합에 대해 곱으로 분해)</li>
          <li>베이즈 정리: \[ P(B_j\mid A) = \frac{P(A\mid B_j)P(B_j)}{\sum_i P(A\mid B_i)P(B_i)} \]</li>
        </ul>
        <p class="mt-2">이제 이 공식을 <b>사전→사후 업데이트</b>, <b>가능도비 누적</b>, <b>나이브 베이즈</b>로 확장해 실전 감각을 쌓습니다.</p>
      </div>
      <div class="mt-4 text-right">
        <a class="text-sm text-blue-700 underline" href="{{ '/bayes/' | prepend: site.baseurl }}">1편(정의/성질) 복습하기 →</a>
      </div>
    </section>

    <!-- Section 0.5: 개념 정리 (초심자용 상세 설명) -->
    <section class="card p-6 mb-10">
      <h2 class="text-2xl font-bold mb-2">개념 정리: 조건부 확률 · 독립 · 베이즈 정리</h2>
      <div class="prose prose-sm max-w-none text-gray-800">
        <h3 class="text-lg font-bold">조건부 확률(Conditional Probability)</h3>
        <p>사건 \(B\)가 일어났다는 정보가 주어졌을 때, 사건 \(A\)가 일어날 확률을 <b>조건부 확률</b>이라고 합니다.</p>
        <p class="mono">\( P(A\mid B) = \dfrac{P(A\cap B)}{P(B)} \), \( P(B\mid A) = \dfrac{P(A\cap B)}{P(A)} \) (단, \(P(B)>0, P(A)>0\))</p>
        <p>즉, ‘둘 다 일어남(교집합)’을 ‘조건이 된 사건의 확률’로 나눈 값입니다. \(B\)가 사실일수록, \(A\)와의 겹치는 정도가 크면 \(P(A\mid B)\)가 커집니다.</p>

        <h3 class="text-lg font-bold mt-4">곱셈 법칙과 직관</h3>
        <p>위 정의를 변형하면 <span class="mono">\(P(A\cap B)=P(A\mid B)P(B)=P(B\mid A)P(A)\)</span>를 얻습니다. 이는 ‘<b>부분×전체</b>’의 직관으로 이해할 수 있습니다. 전체 중 \(B\)의 비율만큼 먼저 줄이고, 그 안에서 다시 \(A\)의 비율만큼 줄이는 식입니다.</p>

        <h3 class="text-lg font-bold mt-4">독립사건(Independence)</h3>
        <p>두 사건이 서로 영향을 주지 않는다면 <span class="mono">\(P(A\cap B)=P(A)P(B)\)</span>가 성립합니다. 여러 사건 \(A_1,\dots,A_n\)에 대해서도 임의의 부분집합의 교집합 확률이 각 확률의 곱으로 분해되면 <b>상호 독립</b>이라고 부릅니다.</p>
        <p>직관적으로, 한 사건의 발생이 다른 사건의 확률을 바꾸지 않는 상태입니다(예: 완벽한 공정의 동전 던지기 결과와 내일 날씨).</p>

        <h3 class="text-lg font-bold mt-4">분할(Partition)과 전확률의 법칙</h3>
        <p>표본공간 \(S\)를 서로 겹치지 않는 \(B_1,\dots,B_K\)로 <b>완전 분할</b>하면, 모든 사건 \(A\)는 \(A=(A\cap B_1)\cup\cdots\cup(A\cap B_K)\)로 쓸 수 있고</p>
        <p class="mono">\( P(A) = \sum_{k=1}^{K} P(A\cap B_k) = \sum_{k=1}^{K} P(A\mid B_k)P(B_k) \)</p>
        <p>이를 <b>전확률의 법칙</b>이라고 부릅니다. 다양한 원인(\(B_k\))이 뒤섞여 만들어낸 결과(\(A\))의 전체 확률을 ‘원인별 합’으로 계산합니다.</p>

        <h3 class="text-lg font-bold mt-4">베이즈 정리(Bayes’ Theorem)</h3>
        <p>우리는 보통 <b>원인을 알고 결과</b>를 예측하는 \(P(A\mid B_k)\)를 쉽게 구합니다. 하지만 실제 궁금한 것은 그 반대, <b>결과를 보고 원인</b>을 추정하는 \(P(B_j\mid A)\)인 경우가 많습니다. 이때 베이즈 정리는 다음을 말해줍니다.</p>
        <p class="mono">\( P(B_j\mid A) = \dfrac{P(A\mid B_j)P(B_j)}{\sum_{k} P(A\mid B_k)P(B_k)} \)</p>
        <p>즉, <b>사후확률</b>(결과를 관측한 뒤 원인의 확률) = <b>가능도</b>(원인 가정 하에서 결과의 그럴듯함) × <b>사전확률</b>(원인에 대한 사전 신념) / <b>정규화 상수</b>(전체 그럴듯함) 입니다.</p>

        <h3 class="text-lg font-bold mt-4">예제: 주가 3일 연속 상승 관측</h3>
        <p>어떤 주식의 하루 상승확률을 \(\theta\)라 할 때, 사전으로 \(P(\theta=0.4)=0.5\), \(P(\theta=0.6)=0.5\)라고 합시다. 서로 다른 날의 등락은 독립이라고 가정합니다.</p>
        <p>이제 3일 연속 상승(사건 \(A\))을 관측했습니다. 그러면</p>
        <p class="mono">\( P(A\mid\theta=0.6) = 0.6^3,\quad P(A\mid\theta=0.4) = 0.4^3 \)</p>
        <p>베이즈 정리에 의해</p>
        <p class="mono">\( P(\theta=0.6\mid A) = \dfrac{(0.6)^3\cdot 0.5}{(0.6)^3\cdot 0.5 + (0.4)^3\cdot 0.5} = 0.7714 \)</p>
        <p>즉, 동일한 관측도 <b>사전 가정</b>과 <b>가능도</b>에 따라 결과가 달라집니다. 데이터가 조금일 때는 사전의 영향이 큽니다.</p>

        <h3 class="text-lg font-bold mt-4">왜 중요한가</h3>
        <p>베이즈 정리는 새로운 정보를 <b>얼마나</b> 반영해야 할지의 원리를 제공합니다. 우리는 종종 <b>베이스레이트 무시</b>나 <b>과잉반응</b>을 하곤 합니다. 베이즈 업데이트는 사전(기존 지식)과 가능도(새 정보)를 균형 있게 결합해 합리적인 의사결정을 돕습니다.</p>
      </div>
      <div class="mt-4 text-right text-sm text-gray-600">아래 상호작용 슬라이더로 사전/가능도/증거를 바꿔 보며 위 개념을 몸으로 익혀보세요.</div>
    </section>

    <!-- Section 1: Beta-Bernoulli Update -->
    <section class="card p-6 mb-10">
      <h2 class="text-2xl font-bold mb-2">1) 베타-베르누이 업데이트: 동전/성공률 추정</h2>
      <p class="text-gray-700 mb-2">베르누이 성공확률을 \(\theta\)라 할 때, 베타 사전 \(\text{Beta}(a,b)\)와 데이터 \(s\)번 성공, \(f\)번 실패를 관측하면</p>
      <p class="text-gray-700 mb-4">사후는 \(\text{Beta}(a+s,\,b+f)\)가 됩니다. 평균/최빈값/분산 근사도 함께 확인하세요.</p>
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div>
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-semibold text-gray-700">사전 a (성공 가중): <span id="aLabel" class="font-bold text-blue-700">2</span></label>
              <input id="a" class="input" type="range" min="1" max="100" value="2">
            </div>
            <div>
              <label class="block text-sm font-semibold text-gray-700">사전 b (실패 가중): <span id="bLabel" class="font-bold text-blue-700">2</span></label>
              <input id="b" class="input" type="range" min="1" max="100" value="2">
            </div>
            <div>
              <label class="block text-sm font-semibold text-gray-700">성공 s: <span id="sLabel" class="font-bold text-emerald-700">8</span></label>
              <input id="s" class="input" type="range" min="0" max="1000" step="1" value="8">
            </div>
            <div>
              <label class="block text-sm font-semibold text-gray-700">실패 f: <span id="fLabel" class="font-bold text-amber-700">12</span></label>
              <input id="f" class="input" type="range" min="0" max="1000" step="1" value="12">
            </div>
            <div class="flex flex-wrap gap-2">
              <button id="presetFair" class="px-3 py-2 rounded bg-gray-200 text-gray-800 text-sm font-semibold hover:bg-gray-300">균일 사전</button>
              <button id="presetStrong" class="px-3 py-2 rounded bg-blue-600 text-white text-sm font-semibold hover:bg-blue-700">강한 사전(0.7)</button>
              <button id="presetWeak" class="px-3 py-2 rounded bg-emerald-600 text-white text-sm font-semibold hover:bg-emerald-700">약한 사전</button>
            </div>
          </div>
        </div>
        <div class="kpi p-4">
          <h3 class="text-lg font-bold mb-3">핵심 지표</h3>
          <div class="grid grid-cols-2 gap-3">
            <div class="p-3 bg-white border rounded">
              <p class="text-xs text-gray-500">사후 평균</p>
              <p id="postMean" class="text-xl font-extrabold">—</p>
            </div>
            <div class="p-3 bg-white border rounded">
              <p class="text-xs text-gray-500">사후 MAP</p>
              <p id="postMAP" class="text-xl font-extrabold">—</p>
            </div>
            <div class="p-3 bg-white border rounded">
              <p class="text-xs text-gray-500">표준편차(근사)</p>
              <p id="postSD" class="text-xl font-extrabold">—</p>
            </div>
            <div class="p-3 bg-white border rounded">
              <p class="text-xs text-gray-500">95% 신뢰구간(근사)</p>
              <p id="postCI" class="text-sm font-bold">—</p>
            </div>
          </div>
          <p class="mt-3 text-sm text-gray-600">근사: <span class="mono">Var[Beta(a',b')] ≈ μ(1−μ)/(a'+b'+1)</span></p>
        </div>
        <div>
          <div class="p-2">
            <canvas id="betaChart" aria-label="베타 분포 사후 밀도 차트" role="img"></canvas>
          </div>
        </div>
      </div>
      <div class="prose prose-sm max-w-none text-gray-800 mt-6">
        <h4 class="text-lg font-bold">왜 베타-베르누이인가?</h4>
        <p>성공확률 \(\theta\)를 가진 베르누이 시행에서 데이터 \(D=(s,f)\)를 관측하면 가능도는 \(\theta^s (1-\theta)^f\)에 비례합니다. 사전이 \(\text{Beta}(a,b)\)일 때 사후는</p>
        <p class="mono">Posterior \(\propto \theta^s(1-\theta)^f\) × Prior \(\propto \theta^{a-1}(1-\theta)^{b-1}\) = \(\theta^{a+s-1}(1-\theta)^{b+f-1}\)</p>
        <p>즉 \(\text{Beta}(a+s,b+f)\)가 되어 계산과 해석이 쉬워집니다. \(a,b\)는 가상의 성공/실패 횟수처럼 해석(유효 표본)할 수 있어 ‘사전 신념의 강도’를 조절합니다.</p>
        <h4 class="text-lg font-bold mt-4">사전이 결과에 미치는 영향</h4>
        <p>데이터가 적을수록(\(s+f\)가 작을수록) 사후 평균 \(\dfrac{a+s}{a+b+s+f}\)은 사전에 더 끌려갑니다. 반대로 관측이 늘면 사전의 영향은 약해지고 빈도적 추정 \(s/(s+f)\)에 수렴합니다.</p>
        <p>실무에서는 “초기 신뢰도”가 높은 상황(예: 이전 A/B 테스트, 장기간 운영된 시스템)에서는 큰 \(a+b\)를, 전혀 정보가 없다면 균일한 \(\text{Beta}(1,1)\) 같은 약한 사전을 씁니다.</p>
      </div>
    </section>

    <!-- Section 2: Likelihood Ratio Chain -->
    <section class="card p-6 mb-10">
      <h2 class="text-2xl font-bold mb-2">2) 가능도비 체인: 증거를 곱해서 누적 업데이트</h2>
      <p class="text-gray-700 mb-2">오즈 업데이트: \( O(H\mid E) = O(H) \times LR \). 여러 독립 증거 \(E_1,\dots,E_k\)에 대해</p>
      <p class="text-gray-700 mb-4">\( O(H\mid E_{1:k}) = O(H) \times \prod_{i=1}^k LR_i \), \( P = \dfrac{O}{1+O} \)로 변환합니다.</p>
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-semibold text-gray-700">사전확률 P(H): <span id="priorPLabel" class="font-bold text-blue-700">10%</span></label>
            <input id="priorP" class="input" type="range" min="0" max="100" value="10">
          </div>
          <div>
            <label class="block text-sm font-semibold text-gray-700">양성 증거 개수(+): <span id="nPosLabel" class="font-bold text-emerald-700">2</span></label>
            <input id="nPos" class="input" type="range" min="0" max="10" value="2">
          </div>
          <div>
            <label class="block text-sm font-semibold text-gray-700">음성 증거 개수(−): <span id="nNegLabel" class="font-bold text-amber-700">1</span></label>
            <input id="nNeg" class="input" type="range" min="0" max="10" value="1">
          </div>
          <div>
            <label class="block text-sm font-semibold text-gray-700">LR(+): <span id="lrPosLabel" class="font-bold text-gray-900">5.0</span></label>
            <input id="lrPos" class="input" type="range" min="1" max="20" step="0.1" value="5">
          </div>
          <div>
            <label class="block text-sm font-semibold text-gray-700">LR(−): <span id="lrNegLabel" class="font-bold text-gray-900">0.2</span></label>
            <input id="lrNeg" class="input" type="range" min="0.05" max="1" step="0.05" value="0.2">
          </div>
        </div>
        <div class="kpi p-4">
          <h3 class="text-lg font-bold mb-3">업데이트 결과</h3>
          <div class="grid grid-cols-2 gap-3">
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">사전 오즈</p><p id="odds0" class="text-xl font-extrabold">—</p></div>
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">사후 오즈</p><p id="oddsK" class="text-xl font-extrabold">—</p></div>
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">사후 확률</p><p id="postP" class="text-xl font-extrabold text-blue-700">—</p></div>
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">총 LR</p><p id="lrTot" class="text-xl font-extrabold">—</p></div>
          </div>
        </div>
        <div>
          <div class="p-2">
            <canvas id="lrChart" aria-label="증거 단계별 사후확률 변화 라인차트" role="img"></canvas>
          </div>
        </div>
      </div>
      <div class="prose prose-sm max-w-none text-gray-800 mt-6">
        <h4 class="text-lg font-bold">LR 해석과 직관</h4>
        <p>가능도비 \(LR=\dfrac{P(E\mid H)}{P(E\mid \neg H)}\)는 ‘증거가 가설 하에서 얼마나 더 그럴듯한가’를 수치화합니다. \(LR>1\)이면 H에 우호적, \(<1\)이면 반대입니다.</p>
        <p>오즈 업데이트는 곱셈이므로 여러 독립 증거에 대해 <b>로그 스케일</b>(합)로 생각하면 직관이 좋아집니다. 즉 \(\log O(H\mid E_{1:k}) = \log O(H) + \sum_i \log LR_i\).</p>
        <p>진료/검사, 부정행위 탐지, 신용평가 등에서 서로 다른 신호를 단계적으로 반영할 때 널리 쓰입니다.</p>
      </div>
    </section>

    <!-- Section 3: Mini Naive Bayes -->
    <section class="card p-6 mb-6">
      <h2 class="text-2xl font-bold mb-2">3) 미니 나이브 베이즈: 스팸 판별 토이 모델</h2>
      <p class="text-gray-700 mb-4">단어 존재 여부가 조건부 독립일 때, \( P(SPAM\mid d) \propto P(SPAM) \prod_i P(w_i\mid SPAM) \). 라플라스 스무딩 사용.</p>
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div>
          <div class="mb-3">
            <label class="block text-sm font-semibold text-gray-700">사전 스팸 확률 P(SPAM): <span id="spamPriorLabel" class="font-bold text-blue-700">30%</span></label>
            <input id="spamPrior" class="input" type="range" min="0" max="100" value="30">
          </div>
          <div class="space-y-2">
            <p class="text-sm font-semibold text-gray-700 mb-1">단어 체크(존재)</p>
            <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="w_free" checked> free</label>
            <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="w_win"> win</label>
            <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="w_offer"> offer</label>
            <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="w_meeting"> meeting</label>
          </div>
          <p class="text-xs text-gray-500 mt-2">사전 말뭉치(예시)에서 추정된 조건부 확률을 사용합니다.</p>
        </div>
        <div class="kpi p-4">
          <h3 class="text-lg font-bold mb-3">결과</h3>
          <div class="grid grid-cols-2 gap-3">
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">P(SPAM|문서)</p><p id="pSpamDoc" class="text-xl font-extrabold text-red-600">—</p></div>
            <div class="p-3 bg-white border rounded"><p class="text-xs text-gray-500">P(HAM|문서)</p><p id="pHamDoc" class="text-xl font-extrabold text-emerald-600">—</p></div>
            <div class="p-3 bg-white border rounded col-span-2"><p class="text-xs text-gray-500">로그-오즈</p><p id="logOddsNB" class="text-xl font-extrabold">—</p></div>
          </div>
        </div>
        <div>
          <div class="p-2">
            <canvas id="nbChart" aria-label="나이브 베이즈 사후확률 도넛차트" role="img"></canvas>
          </div>
        </div>
      </div>
      <div class="prose prose-sm max-w-none text-gray-800 mt-6">
        <h4 class="text-lg font-bold">나이브 가정과 스무딩</h4>
        <p>나이브 베이즈는 특징 간 상관을 무시(조건부 독립)하여 계산을 단순화합니다. 현실에서는 완전 독립이 아니어도 surprisingly robust 합니다.</p>
        <p>라플라스 스무딩은 관측이 0인 단어의 확률 붕괴를 막아주며, \(P(w\mid C)=\dfrac{\text{count}(w,C)+\alpha}{\sum_v \text{count}(v,C)+\alpha|V|}\) 형태를 자주 씁니다(\(\alpha=1\) 기본).</p>
        <p>소규모 데이터에 강하고, 베이스라인 분류기로 유용합니다. 단, 긴 의존구조나 연속 변수를 다룰 때는 가우시안/멀티노미얼 변형 등으로 확장합니다.</p>
      </div>
    </section>

    <section class="text-sm text-gray-500">
      <p>참고: 조건부 독립 가정은 현실에서 완벽히 성립하지 않을 수 있으므로, 특징 상관관계를 다루는 모델(예: 로지스틱 회귀, 트리 기반 모델)과 비교 검증을 권장합니다.</p>
    </section>
  </div>
</div>

<script>
  const $ = (id) => document.getElementById(id);

  // ---------- Section 1: Beta-Bernoulli ----------
  let aEl = $('a'), bEl = $('b'), sEl = $('s'), fEl = $('f');
  let aLabel = $('aLabel'), bLabel = $('bLabel'), sLabel = $('sLabel'), fLabel = $('fLabel');
  let postMean = $('postMean'), postMAP = $('postMAP'), postSD = $('postSD'), postCI = $('postCI');
  let betaChart;

  function lnGamma(z) { // Lanczos approximation
    const g = 7;
    const p = [
      0.99999999999980993, 676.5203681218851, -1259.1392167224028,
      771.32342877765313, -176.61502916214059, 12.507343278686905,
      -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
    ];
    if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - lnGamma(1 - z);
    z -= 1;
    let x = p[0];
    for (let i = 1; i < g + 2; i++) x += p[i] / (z + i);
    const t = z + g + 0.5;
    return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x) - Math.log(z+1);
  }
  function betaFunc(a,b){ return Math.exp(lnGamma(a)+lnGamma(b)-lnGamma(a+b)); }
  function betaPDF(x,a,b){ if(x<=0||x>=1) return 0; return Math.exp((a-1)*Math.log(x)+(b-1)*Math.log(1-x)-Math.log(betaFunc(a,b))); }

  function updateBeta() {
    const a = Number(aEl.value), b = Number(bEl.value), s = Number(sEl.value), f = Number(fEl.value);
    aLabel.textContent = a; bLabel.textContent = b; sLabel.textContent = s; fLabel.textContent = f;
    const ap = a + s, bp = b + f; // posterior params
    const mean = ap/(ap+bp);
    const variance = (mean*(1-mean))/((ap+bp)+1);
    const sd = Math.sqrt(variance);
    const map = (ap>1 && bp>1) ? (ap-1)/(ap+bp-2) : mean; // mode approx
    const lo = Math.max(0, mean - 1.96*sd), hi = Math.min(1, mean + 1.96*sd);

    postMean.textContent = (mean*100).toFixed(2) + '%';
    postMAP.textContent = (map*100).toFixed(2) + '%';
    postSD.textContent = sd.toFixed(4);
    postCI.textContent = `${(lo*100).toFixed(1)}% ~ ${(hi*100).toFixed(1)}%`;

    // chart
    const xs = [], ys = [];
    for (let i=0;i<=100;i++){ const x=i/100; xs.push(x); ys.push(betaPDF(x, ap, bp)); }
    const ctx = document.getElementById('betaChart').getContext('2d');
    const cfg = {
      type: 'line',
      data: { labels: xs.map(v=>v.toFixed(2)), datasets: [{ label: '사후 밀도', data: ys, borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.15)', fill:true, tension:0.25 }] },
      options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom' } }, scales:{ x:{ ticks:{ callback:(v)=> xs[v] } } } }
    };
    if (betaChart) { betaChart.data.labels = cfg.data.labels; betaChart.data.datasets[0].data = ys; betaChart.update(); }
    else { betaChart = new Chart(ctx, cfg); }
  }

  $('presetFair').addEventListener('click', ()=>{ aEl.value=1; bEl.value=1; sEl.value=8; fEl.value=12; updateBeta(); });
  $('presetStrong').addEventListener('click', ()=>{ aEl.value=14; bEl.value=6; sEl.value=8; fEl.value=12; updateBeta(); }); // mean~0.7
  $('presetWeak').addEventListener('click', ()=>{ aEl.value=2; bEl.value=2; sEl.value=8; fEl.value=12; updateBeta(); });
  [aEl,bEl,sEl,fEl].forEach(el=> el.addEventListener('input', updateBeta));

  // ---------- Section 2: LR Chain ----------
  let priorP = $('priorP'), nPos = $('nPos'), nNeg = $('nNeg'), lrPos = $('lrPos'), lrNeg = $('lrNeg');
  let priorPLabel = $('priorPLabel'), nPosLabel = $('nPosLabel'), nNegLabel = $('nNegLabel'), lrPosLabel = $('lrPosLabel'), lrNegLabel = $('lrNegLabel');
  let odds0El = $('odds0'), oddsKEl = $('oddsK'), postPEl = $('postP'), lrTotEl = $('lrTot');
  let lrChart;

  function updateLR() {
    const p0 = Number(priorP.value)/100;
    const nP = Number(nPos.value), nN = Number(nNeg.value);
    const lrp = Number(lrPos.value), lrn = Number(lrNeg.value);
    priorPLabel.textContent = `${priorP.value}%`;
    nPosLabel.textContent = nP; nNegLabel.textContent = nN;
    lrPosLabel.textContent = lrp.toFixed(2); lrNegLabel.textContent = lrn.toFixed(2);

    const O0 = p0/(1-p0 || 1e-12);
    const LRtot = Math.pow(lrp, nP) * Math.pow(lrn, nN);
    const Ok = O0 * LRtot;
    const pk = Ok/(1+Ok);

    odds0El.textContent = O0.toFixed(3);
    oddsKEl.textContent = Ok.toFixed(3);
    lrTotEl.textContent = LRtot.toFixed(3);
    postPEl.textContent = (pk*100).toFixed(2) + '%';

    // stepwise path: apply positives then negatives
    const steps = [];
    let Ostep = O0;
    for (let i=0;i<nP;i++){ Ostep *= lrp; steps.push(Ostep/(1+Ostep)); }
    for (let i=0;i<nN;i++){ Ostep *= lrn; steps.push(Ostep/(1+Ostep)); }

    const labels = steps.map((_,i)=>`증거 ${i+1}`);
    const ctx = document.getElementById('lrChart').getContext('2d');
    const cfg = {
      type: 'line',
      data: { labels, datasets: [{ label:'사후확률(단계)', data: steps.map(v=> v*100), borderColor:'#16a34a', backgroundColor:'rgba(22,163,74,0.15)', fill:true, tension:0.25 }] },
      options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom' } }, scales:{ y:{ min:0, max:100, ticks:{ callback:(v)=> v+'%' } } } }
    };
    if (lrChart) { lrChart.data.labels = labels; lrChart.data.datasets[0].data = cfg.data.datasets[0].data; lrChart.update(); }
    else { lrChart = new Chart(ctx, cfg); }
  }

  [priorP, nPos, nNeg, lrPos, lrNeg].forEach(el=> el.addEventListener('input', updateLR));

  // ---------- Section 3: Mini Naive Bayes ----------
  const vocab = ['free','win','offer','meeting'];
  const condSpam = { free:0.60, win:0.45, offer:0.30, meeting:0.05 };
  const condHam  = { free:0.05, win:0.02, offer:0.08, meeting:0.40 };
  let spamPrior = $('spamPrior'), spamPriorLabel = $('spamPriorLabel');
  let pSpamDoc = $('pSpamDoc'), pHamDoc = $('pHamDoc'), logOddsNB = $('logOddsNB');
  let nbChart;

  function updateNB() {
    const pSpam = Number(spamPrior.value)/100;
    spamPriorLabel.textContent = `${spamPrior.value}%`;
    const words = {
      free: $('w_free').checked,
      win: $('w_win').checked,
      offer: $('w_offer').checked,
      meeting: $('w_meeting').checked,
    };

    // Laplace smoothing on presence/absence for each word
    const eps = 1e-6;
    let logPDocGivenSpam = 0, logPDocGivenHam = 0;
    for (const w of vocab) {
      const p1s = condSpam[w], p1h = condHam[w];
      const p0s = 1 - p1s, p0h = 1 - p1h;
      if (words[w]) { logPDocGivenSpam += Math.log(p1s+eps); logPDocGivenHam += Math.log(p1h+eps); }
      else { logPDocGivenSpam += Math.log(p0s+eps); logPDocGivenHam += Math.log(p0h+eps); }
    }
    const logPriorOdds = Math.log(pSpam+eps) - Math.log(1-pSpam+eps);
    const logLR = logPDocGivenSpam - logPDocGivenHam;
    const logOdds = logPriorOdds + logLR;
    const odds = Math.exp(logOdds);
    const pSpamPost = odds/(1+odds);
    const pHamPost = 1 - pSpamPost;

    pSpamDoc.textContent = (pSpamPost*100).toFixed(2) + '%';
    pHamDoc.textContent = (pHamPost*100).toFixed(2) + '%';
    logOddsNB.textContent = logOdds.toFixed(3);

    const ctx = document.getElementById('nbChart').getContext('2d');
    const cfg = {
      type: 'doughnut',
      data: { labels:['SPAM','HAM'], datasets:[{ data:[pSpamPost, pHamPost], backgroundColor:['#dc2626','#16a34a'], borderColor:'#fff', borderWidth:2 }] },
      options: { responsive:true, maintainAspectRatio:false, cutout:'60%', plugins:{ legend:{ position:'bottom' } } }
    };
    if (nbChart) { nbChart.data.datasets[0].data = [pSpamPost, pHamPost]; nbChart.update(); }
    else { nbChart = new Chart(ctx, cfg); }
  }

  ['w_free','w_win','w_offer','w_meeting'].forEach(id=> $(id).addEventListener('change', updateNB));
  spamPrior.addEventListener('input', updateNB);

  // initial renders
  updateBeta();
  updateLR();
  updateNB();
</script>

<section id="related-posts" class="max-w-4xl mx-auto my-12 p-6 bg-gradient-to-br from-cyan-50 to-blue-50 rounded-xl shadow-lg border border-cyan-200">
    <h2 class="text-2xl font-bold text-center mb-6 text-gray-900">🔗 관련 글 읽어보기</h2>
    <div class="space-y-4">
        <div>
            <h3 class="text-lg font-semibold text-gray-800 mb-2">📊 투자 전략</h3>
            <ul class="list-disc list-inside space-y-2 ml-4 text-gray-700">
                <li><a href="https://junpyopark.github.io/kelly-invest/" target="_blank" class="text-blue-600 hover:text-blue-800 hover:underline font-medium">켈리 공식과 포지션 사이징</a> - 확률과 베팅 사이즈의 관계</li>
                <li><a href="https://junpyopark.github.io/thistimedifferent/" target="_blank" class="text-blue-600 hover:text-blue-800 hover:underline font-medium">이번엔 다르다: 800년 금융 위기</a> - 조기 경보 지표와 확률 업데이트</li>
            </ul>
        </div>
        <div>
            <h3 class="text-lg font-semibold text-gray-800 mb-2">💰 암호화폐</h3>
            <ul class="list-disc list-inside space-y-2 ml-4 text-gray-700">
                <li><a href="https://junpyopark.github.io/infocoin/" target="_blank" class="text-blue-600 hover:text-blue-800 hover:underline font-medium">마이클 세일러의 비트코인 매트릭스</a> - 베이지안 업데이트로 보는 비트코인</li>
            </ul>
        </div>
    </div>
</section> 